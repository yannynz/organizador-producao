{"version":3,"file":"stomp-ng2-stompjs.js.map","sources":["ng://@stomp/ng2-stompjs/src/app/compatibility/stomp-r.service.ts","ng://@stomp/ng2-stompjs/src/app/compatibility/stomp.config.ts","ng://@stomp/ng2-stompjs/src/app/compatibility/stomp.service.ts","ng://@stomp/ng2-stompjs/src/app/rx-stomp.service.ts","ng://@stomp/ng2-stompjs/src/app/injectable-rx-stomp-rpc-config.ts","ng://@stomp/ng2-stompjs/src/app/rx-stomp-rpc.service.ts","ng://@stomp/ng2-stompjs/src/app/injectable-rx-stomp-config.ts","ng://@stomp/ng2-stompjs/src/app/rx-stomp-service-factory.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\nimport { RxStomp, RxStompConfig, RxStompState } from '@stomp/rx-stomp';\n\nimport { publishParams, Client, Message, Frame } from '@stomp/stompjs';\n\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { StompState } from './stomp-state';\nimport { StompHeaders } from './stomp-headers';\nimport { StompConfig } from './stomp.config';\n\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * **This class has been deprecated in favor of {@link RxStompService}.\n * It will be dropped `@stomp/ng2-stompjs@8.x.x`.**\n *\n * Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\n@Injectable()\nexport class StompRService extends RxStomp {\n  /**\n   * State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.\n   */\n  public state: BehaviorSubject<StompState>;\n\n  private static _mapStompState(st: RxStompState): StompState {\n    if (st === RxStompState.CONNECTING) {\n      return StompState.TRYING;\n    }\n    if (st === RxStompState.OPEN) {\n      return StompState.CONNECTED;\n    }\n    if (st === RxStompState.CLOSING) {\n      return StompState.DISCONNECTING;\n    }\n    if (st === RxStompState.CLOSED) {\n      return StompState.CLOSED;\n    }\n  }\n\n  /**\n   * Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED\n   */\n  get connectObservable(): Observable<StompState> {\n    return this.connected$.pipe(\n      map(\n        (st: RxStompState): StompState => {\n          return StompRService._mapStompState(st);\n        }\n      )\n    );\n  }\n\n  /**\n   * Provides headers from most recent connection to the server as return by the CONNECTED\n   * frame.\n   * If the STOMP connection has already been established it will trigger immediately.\n   * It will additionally trigger in event of reconnection, the value will be set of headers from\n   * the recent server response.\n   */\n  get serverHeadersObservable(): Observable<StompHeaders> {\n    return this.serverHeaders$;\n  }\n\n  /**\n   * Will emit all messages to the default queue (any message that are not handled by a subscription)\n   */\n  get defaultMessagesObservable(): Subject<Message> {\n    return this.unhandledMessage$;\n  }\n\n  /**\n   * Will emit all receipts\n   */\n  get receiptsObservable(): Subject<Frame> {\n    return this.unhandledReceipts$;\n  }\n\n  /**\n   * Will trigger when an error occurs. This Subject can be used to handle errors from\n   * the stomp broker.\n   */\n  get errorSubject(): Subject<string | Frame> {\n    return this.stompErrors$;\n  }\n\n  /** Set configuration */\n  set config(config: StompConfig) {\n    const rxStompConfig: RxStompConfig = {};\n\n    if (typeof config.url === 'string') {\n      rxStompConfig.brokerURL = config.url;\n    } else {\n      rxStompConfig.webSocketFactory = config.url;\n    }\n\n    // Configure client heart-beating\n    rxStompConfig.heartbeatIncoming = config.heartbeat_in;\n    rxStompConfig.heartbeatOutgoing = config.heartbeat_out;\n\n    // Auto reconnect\n    rxStompConfig.reconnectDelay = config.reconnect_delay;\n\n    if (config.debug) {\n      rxStompConfig.debug = (str: string): void => {\n        console.log(new Date(), str);\n      };\n    }\n\n    rxStompConfig.connectHeaders = config.headers;\n\n    this.configure(rxStompConfig);\n  }\n  /**\n   * It will connect to the STOMP broker.\n   */\n  public initAndConnect(): void {\n    // disconnect if connected\n    this.deactivate();\n\n    // Attempt connection, passing in a callback\n    this.activate();\n  }\n\n  /**\n   * It will disconnect from the STOMP broker.\n   */\n  public disconnect(): void {\n    this.deactivate();\n  }\n\n  /**\n   * It will send a message to a named destination. The message must be `string`.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers\n   */\n  public publish(\n    queueName: string | publishParams,\n    message?: string,\n    headers: StompHeaders = {}\n  ): void {\n    if (typeof queueName === 'string') {\n      super.publish({\n        destination: queueName as string,\n        body: message,\n        headers,\n      });\n    } else {\n      const pubParams: publishParams = queueName;\n      super.publish(pubParams);\n    }\n  }\n\n  /**\n   * It will subscribe to server message queues\n   *\n   * This method can be safely called even if the STOMP broker is not connected.\n   * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Note that when working with temporary queues where the subscription request\n   * creates the\n   * underlying queue, messages might be missed during reconnect. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   */\n  public subscribe(\n    queueName: string,\n    headers: StompHeaders = {}\n  ): Observable<Message> {\n    return this.watch(queueName, headers);\n  }\n\n  /**\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n   * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n   * random number or a combination may be used.\n   *\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n   * The operation needs to be matched based in the value of the receipt-id.\n   *\n   * This method allow watching for a receipt and invoke the callback\n   * when corresponding receipt has been received.\n   *\n   * The actual {@link Frame}\n   * will be passed as parameter to the callback.\n   *\n   * Example:\n   * ```javascript\n   *        // Publishing with acknowledgement\n   *        let receiptId = randomText();\n   *\n   *        rxStomp.waitForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *        rxStomp.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n   * ```\n   *\n   * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n   */\n  public waitForReceipt(\n    receiptId: string,\n    callback: (frame: Frame) => void\n  ): void {\n    super.watchForReceipt(receiptId, callback);\n  }\n\n  get client(): Client {\n    return this._stompClient;\n  }\n\n  public constructor() {\n    super();\n\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectionState$.subscribe((st: RxStompState) => {\n      this.state.next(StompRService._mapStompState(st));\n    });\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { StompHeaders } from '@stomp/stompjs';\n\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * **This class has been deprecated in favor of {@link InjectableRxStompConfig}.\n * It will be dropped `@stomp/ng2-stompjs@8.x.x`.**\n *\n * Represents a configuration object for the\n * STOMPService to connect to.\n *\n * This name conflicts with a class of the same name in @stomp/stompjs, excluding this from the documentation.\n *\n * @internal\n */\n@Injectable()\nexport class StompConfig {\n  /**\n   * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n   *\n   * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n   *\n   * Alternatively this parameter can be a function that returns an object similar to WebSocket\n   * (typically SockJS instance).\n   *\n   * Example:\n   *\n   * () => {\n   *   return new SockJS('http://127.0.0.1:15674/stomp');\n   * }\n   */\n  url: string | (() => any);\n\n  /**\n   * Headers\n   * Typical keys: login: string, passcode: string.\n   * host:string will neeed to be passed for virtual hosts in RabbitMQ\n   */\n  headers: StompHeaders;\n\n  /** How often to incoming heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 0 - disabled\n   */\n  heartbeat_in: number;\n\n  /**\n   * How often to outgoing heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 20000 - every 20 seconds\n   */\n  heartbeat_out: number;\n\n  /**\n   * Wait in milliseconds before attempting auto reconnect\n   * Set to 0 to disable\n   *\n   * Typical value 5000 (5 seconds)\n   */\n  reconnect_delay: number;\n\n  /** Enable client debugging? */\n  debug: boolean;\n}\n","import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * **This class has been deprecated in favor of {@link RxStompService} with {@link rxStompServiceFactory}.\n * It will be dropped `@stomp/ng2-stompjs@8.x.x`.**\n *\n * Angular2 STOMP Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you want to manually configure and initialize the service\n * please use StompRService\n */\n@Injectable()\nexport class StompService extends StompRService {\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { RxStomp } from '@stomp/rx-stomp';\n\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * This class is Injectable version of {@link RxStomp} with exactly same functionality.\n * Please see {@link RxStomp} for details.\n *\n * See: {@link /guide/ng2-stompjs/ng2-stomp-with-angular7.html}\n * for a step-by-step guide.\n *\n * See also {@link rxStompServiceFactory}.\n */\n@Injectable()\nexport class RxStompService extends RxStomp {}\n","import { Injectable } from '@angular/core';\nimport { RxStompRPCConfig } from '@stomp/rx-stomp';\n\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * Injectable version of {@link RxStompRPCConfig}.\n *\n * See guide at {@link /guide/rx-stomp/ng2-stompjs/remote-procedure-call.html}\n */\n@Injectable()\nexport class InjectableRxStompRPCConfig extends RxStompRPCConfig {}\n\n// Backward compatibility\n/**\n * Deprecated, use {@link InjectableRxStompRPCConfig} instead\n */\nexport const InjectableRxStompRpcConfig = InjectableRxStompRPCConfig;\n","import { Injectable, Optional } from '@angular/core';\n\nimport { RxStompRPC } from '@stomp/rx-stomp';\nimport { RxStompService } from './rx-stomp.service';\nimport { InjectableRxStompRPCConfig } from './injectable-rx-stomp-rpc-config';\n\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * Injectable version of {@link RxStompRPC}.\n *\n * See guide at {@link /guide/rx-stomp/ng2-stompjs/remote-procedure-call.html}\n */\n@Injectable()\nexport class RxStompRPCService extends RxStompRPC {\n  /**\n   * Create an instance, typically called by Angular Dependency Injection framework.\n   *\n   * @param rxStomp\n   * @param stompRPCConfig\n   */\n  constructor(\n    rxStomp: RxStompService,\n    @Optional() stompRPCConfig?: InjectableRxStompRPCConfig\n  ) {\n    super(rxStomp, stompRPCConfig);\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { RxStompConfig } from '@stomp/rx-stomp';\n\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * This class is Injectable version of {@link RxStompConfig} with exactly same functionality.\n * Please see {@link RxStompConfig} for details.\n *\n * See: {@link /guide/ng2-stompjs/ng2-stomp-with-angular7.html}\n * for a step-by-step guide.\n *\n * If all fields of configuration are fixed and known in advance you would typically define\n * a `const` and inject it using value.\n *\n * If some fields will be known by later, it can be injected using a factory function.\n *\n * Occasionally it may need to be combined with Angular's APP_INITIALIZER mechanism.\n */\n@Injectable()\nexport class InjectableRxStompConfig extends RxStompConfig {}\n","import { InjectableRxStompConfig } from './injectable-rx-stomp-config';\nimport { RxStompService } from './rx-stomp.service';\n\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * This is factory function that can create {@link RxStompService}\n * when configuration is already known.\n * You can use this function for defining provider for {@link RxStompService}.\n * {@link RxStompService} created using this function is configured and activated.\n * This provides the simplest mechanism to define {@link RxStompService} for Dependency Injection.\n *\n * See: {@link /guide/ng2-stompjs/ng2-stomp-with-angular7.html}\n * for a step-by-step guide.\n */\nexport function rxStompServiceFactory(\n  rxStompConfig: InjectableRxStompConfig\n): RxStompService {\n  const rxStompService = new RxStompService();\n\n  rxStompService.configure(rxStompConfig);\n  rxStompService.activate();\n\n  return rxStompService;\n}\n"],"names":[],"mappings":"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"}
