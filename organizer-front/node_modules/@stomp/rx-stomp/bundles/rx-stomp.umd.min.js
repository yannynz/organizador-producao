!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("rxjs"),require("rxjs/operators"),require("@stomp/stompjs")):"function"==typeof define&&define.amd?define("RxStomp",["rxjs","rxjs/operators","@stomp/stompjs"],t):"object"==typeof exports?exports.RxStomp=t(require("rxjs"),require("rxjs/operators"),require("@stomp/stompjs")):e.RxStomp=t(e.rxjs,e.rxjs.operators,e.StompJs)}("undefined"!=typeof self?self:this,(function(e,t,s){return(()=>{"use strict";var n={458:(e,t)=>{var s=function(){function e(){}return e.UUID=function(){if("undefined"!=typeof window&&void 0!==window.crypto&&void 0!==window.crypto.getRandomValues){var e=new Uint16Array(8);return window.crypto.getRandomValues(e),this.pad4(e[0])+this.pad4(e[1])+"-"+this.pad4(e[2])+"-"+this.pad4(e[3])+"-"+this.pad4(e[4])+"-"+this.pad4(e[5])+this.pad4(e[6])+this.pad4(e[7])}return this.random4()+this.random4()+"-"+this.random4()+"-"+this.random4()+"-"+this.random4()+"-"+this.random4()+this.random4()+this.random4()},e.pad4=function(e){for(var t=e.toString(16);t.length<4;)t="0"+t;return t},e.random4=function(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)},e}();t.h=s},102:e=>{e.exports=s},443:e=>{e.exports=t},318:t=>{t.exports=e}},r={};function i(e){var t=r[e];if(void 0!==t)return t.exports;var s=r[e]={exports:{}};return n[e](s,s.exports,i),s.exports}i.d=(e,t)=>{for(var s in t)i.o(t,s)&&!i.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};return(()=>{i.r(o),i.d(o,{RxStomp:()=>c,RxStompConfig:()=>e,RxStompRPC:()=>d,RxStompRPCConfig:()=>a,RxStompState:()=>t});class e{}var t,s=i(318),n=i(443),r=i(102);!function(e){e[e.CONNECTING=0]="CONNECTING",e[e.OPEN=1]="OPEN",e[e.CLOSING=2]="CLOSING",e[e.CLOSED=3]="CLOSED"}(t||(t={}));var u=function(e,t,s,n){return new(s||(s=Promise))((function(r,i){function o(e){try{c(n.next(e))}catch(e){i(e)}}function u(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof s?t:new s((function(e){e(t)}))).then(o,u)}c((n=n.apply(e,t||[])).next())}))};class c{constructor(e){this._queuedMessages=[];const i=e||new r.Client;this._stompClient=i;const o=()=>{};this._beforeConnect=o,this._correlateErrors=()=>{},this._debug=o,this._connectionStatePre$=new s.BehaviorSubject(t.CLOSED),this._connectedPre$=this._connectionStatePre$.pipe((0,n.filter)((e=>e===t.OPEN))),this.connectionState$=new s.BehaviorSubject(t.CLOSED),this.connected$=this.connectionState$.pipe((0,n.filter)((e=>e===t.OPEN))),this.connected$.subscribe((()=>{this._sendQueuedMessages()})),this._serverHeadersBehaviourSubject$=new s.BehaviorSubject(null),this.serverHeaders$=this._serverHeadersBehaviourSubject$.pipe((0,n.filter)((e=>null!==e))),this.stompErrors$=new s.Subject,this.unhandledMessage$=new s.Subject,this.unhandledReceipts$=new s.Subject,this.unhandledFrame$=new s.Subject,this.webSocketErrors$=new s.Subject}get stompClient(){return this._stompClient}configure(e){const t=Object.assign({},e);t.beforeConnect&&(this._beforeConnect=t.beforeConnect,delete t.beforeConnect),t.correlateErrors&&(this._correlateErrors=t.correlateErrors,delete t.correlateErrors),this._stompClient.configure(t),t.debug&&(this._debug=t.debug)}activate(){this._stompClient.configure({beforeConnect:()=>u(this,void 0,void 0,(function*(){this._changeState(t.CONNECTING),yield this._beforeConnect(this)})),onConnect:e=>{this._serverHeadersBehaviourSubject$.next(e.headers),this._changeState(t.OPEN)},onStompError:e=>{this.stompErrors$.next(e)},onWebSocketClose:()=>{this._changeState(t.CLOSED)},onUnhandledMessage:e=>{this.unhandledMessage$.next(e)},onUnhandledReceipt:e=>{this.unhandledReceipts$.next(e)},onUnhandledFrame:e=>{this.unhandledFrame$.next(e)},onWebSocketError:e=>{this.webSocketErrors$.next(e)}}),this._stompClient.activate()}deactivate(){return u(this,void 0,void 0,(function*(){this._changeState(t.CLOSING),yield this._stompClient.deactivate(),this._changeState(t.CLOSED)}))}connected(){return this.connectionState$.getValue()===t.OPEN}get active(){return this.stompClient.active}publish(e){const t=null==e.retryIfDisconnected||e.retryIfDisconnected;if(this.connected())this._stompClient.publish(e);else{if(!t)throw new Error("Cannot publish while broker is not connected");this._debug("Not connected, queueing"),this._queuedMessages.push(e)}}_sendQueuedMessages(){const e=this._queuedMessages;if(this._queuedMessages=[],0!==e.length){this._debug(`Will try sending  ${e.length} queued message(s)`);for(const t of e)this._debug(`Attempting to send ${t}`),this.publish(t)}}watch(e,t={}){const r={subHeaders:{},unsubHeaders:{},subscribeOnlyOnce:!1};let i;return i="string"==typeof e?Object.assign({},r,{destination:e,subHeaders:t}):Object.assign({},r,e),this._debug(`Request to subscribe ${i.destination}`),s.Observable.create((e=>{let t,s,r=this._connectedPre$;i.subscribeOnlyOnce&&(r=r.pipe((0,n.take)(1)));const o=this.stompErrors$.subscribe((t=>{this._correlateErrors(t)===i.destination&&e.error(t)}));return s=r.subscribe((()=>{this._debug(`Will subscribe to ${i.destination}`);let s=i.subHeaders;"function"==typeof s&&(s=s()),t=this._stompClient.subscribe(i.destination,(t=>{e.next(t)}),s)})),()=>{if(this._debug(`Stop watching connection state (for ${i.destination})`),s.unsubscribe(),o.unsubscribe(),this.connected()){this._debug(`Will unsubscribe from ${i.destination} at Stomp`);let e=i.unsubHeaders;"function"==typeof e&&(e=e()),t.unsubscribe(e)}else this._debug(`Stomp not connected, no need to unsubscribe from ${i.destination} at Stomp`)}})).pipe((0,n.share)())}watchForReceipt(e,t){this._stompClient.watchForReceipt(e,t)}_changeState(e){this._connectionStatePre$.next(e),this.connectionState$.next(e)}}class a{}var h=i(458);class d{constructor(e,t){this.rxStomp=e,this.stompRPCConfig=t,this._replyQueueName="/temp-queue/rpc-replies",this._setupReplyQueue=()=>this.rxStomp.unhandledMessage$,this._customReplyQueue=!1,t&&(t.replyQueueName&&(this._replyQueueName=t.replyQueueName),t.setupReplyQueue&&(this._customReplyQueue=!0,this._setupReplyQueue=t.setupReplyQueue))}rpc(e){return this.stream(e).pipe((0,n.first)())}stream(e){const t=Object.assign({},e.headers||{});if(!this._repliesObservable){const e=this._setupReplyQueue(this._replyQueueName,this.rxStomp);this._customReplyQueue&&(this._dummySubscription=e.subscribe((()=>{}))),this._repliesObservable=e}return s.Observable.create((s=>{let r;const i=t["correlation-id"]||h.h.UUID();return r=this._repliesObservable.pipe((0,n.filter)((e=>e.headers["correlation-id"]===i))).subscribe((e=>{s.next(e)})),t["reply-to"]=this._replyQueueName,t["correlation-id"]=i,this.rxStomp.publish(Object.assign(Object.assign({},e),{headers:t})),()=>{r.unsubscribe()}}))}}})(),o})()}));
//# sourceMappingURL=rx-stomp.umd.min.js.map